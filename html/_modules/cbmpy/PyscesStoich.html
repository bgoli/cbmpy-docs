<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>cbmpy.PyscesStoich &#8212; CBMPy 0.7.13 documentation</title>
    
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.7.13',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within CBMPy 0.7.13 documentation"
          href="../../_static/opensearch.xml"/>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="top" title="CBMPy 0.7.13 documentation" href="../../cbmpy.html" />
    <link rel="up" title="Module code" href="../index.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for cbmpy.PyscesStoich</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">PySCeS - Python Simulator for Cellular Systems (http://pysces.sourceforge.net)</span>

<span class="sd">Copyright (C) 2004-2017 B.G. Olivier, J.M. Rohwer, J.-H.S Hofmeyr all rights reserved,</span>

<span class="sd">Brett G. Olivier (bgoli@users.sourceforge.net)</span>
<span class="sd">Triple-J Group for Molecular Cell Physiology</span>
<span class="sd">Stellenbosch University, South Africa.</span>

<span class="sd">Permission to use, modify, and distribute this software is given under the</span>
<span class="sd">terms of the PySceS (BSD style) license. See LICENSE.txt that came with</span>
<span class="sd">this distribution for specifics.</span>

<span class="sd">NO WARRANTY IS EXPRESSED OR IMPLIED.  USE AT YOUR OWN RISK.</span>
<span class="sd">Brett G. Olivier</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># preparing for Python 3 port</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span>
<span class="c1">#from __future__ import unicode_literals</span>


<span class="kn">from</span> <span class="nn">cbmpy.CBConfig</span> <span class="k">import</span> <span class="n">__CBCONFIG__</span> <span class="k">as</span> <span class="n">__CBCONFIG__</span>
<span class="n">__DEBUG__</span> <span class="o">=</span> <span class="n">__CBCONFIG__</span><span class="p">[</span><span class="s1">&#39;DEBUG&#39;</span><span class="p">]</span>
<span class="n">__version__</span> <span class="o">=</span> <span class="n">__CBCONFIG__</span><span class="p">[</span><span class="s1">&#39;VERSION&#39;</span><span class="p">]</span>

<span class="kn">import</span> <span class="nn">time</span><span class="o">,</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">scipy</span>
<span class="kn">import</span> <span class="nn">scipy.linalg</span>
<span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">__version__</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">12</span><span class="p">:</span>
    <span class="n">myfblas</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">fblas</span>
    <span class="n">myflapack</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">flapack</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">myfblas</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">blas</span>
    <span class="n">myflapack</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lapack</span>

<span class="kn">import</span> <span class="nn">copy</span>

<span class="n">__doc__</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">          PyscesStoich</span>
<span class="s2">          ------------</span>
<span class="s2">          PySCeS stoichiometric analysis classes.</span>

<span class="s2">          &quot;&quot;&quot;</span>

<span class="c1">##  print(&#39;Stoichiometry ver &#39; + __version__ + &#39; runtime: &#39;+ time.strftime(&quot;%H:%M:%S&quot;))</span>

<span class="n">__psyco_active__</span> <span class="o">=</span> <span class="mi">0</span>
<span class="c1">##  try:</span>
    <span class="c1">##  import psyco</span>
    <span class="c1">##  psyco.profile()</span>
    <span class="c1">##  __psyco_active__ = 1</span>
    <span class="c1">##  print &#39;PySCeS Stoichiometry Module is now PsycoActive!&#39;</span>
<span class="c1">##  except:</span>
    <span class="c1">##  __psyco_active__ = 0</span>

<span class="c1">##stoich_zero_valM = scipy.machar.MachAr().eps*2.0e4 # safer --&gt; about 4e-11 (unofficially - a minpivot size)</span>
<span class="c1">##stoich_zero_valM = scipy.machar.MachAr().eps*2.0e4 # safe --&gt; about 4e-12 (unofficially - a minpivot size)</span>
<span class="c1">##print &#39;\tStoichiometric precision = &#39;, stoich_zero_valM</span>

<div class="viewcode-block" id="StructMatrix"><a class="viewcode-back" href="../../modules_doc.html#cbmpy.PyscesStoich.StructMatrix">[docs]</a><span class="k">class</span> <span class="nc">StructMatrix</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class is specifically designed to store structural matrix information</span>
<span class="sd">    give it an array and row/col index permutations it can generate its own</span>
<span class="sd">    row/col labels given the label src.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">array</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">ridx</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">cidx</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">row</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">col</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">ridx</span><span class="p">,</span> <span class="n">cidx</span><span class="p">,</span> <span class="n">row</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">col</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Instantiate with array and matching row/col index arrays, optional label arrays</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">array</span> <span class="o">=</span> <span class="n">array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ridx</span> <span class="o">=</span> <span class="n">ridx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cidx</span> <span class="o">=</span> <span class="n">cidx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">row</span> <span class="o">=</span> <span class="n">row</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">col</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">array</span>

<div class="viewcode-block" id="StructMatrix.getRowsByIdx"><a class="viewcode-back" href="../../modules_doc.html#cbmpy.PyscesStoich.StructMatrix.getRowsByIdx">[docs]</a>    <span class="k">def</span> <span class="nf">getRowsByIdx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the rows referenced by index (1,3,5)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="StructMatrix.getColsByIdx"><a class="viewcode-back" href="../../modules_doc.html#cbmpy.PyscesStoich.StructMatrix.getColsByIdx">[docs]</a>    <span class="k">def</span> <span class="nf">getColsByIdx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the columns referenced by index (1,3,5)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="StructMatrix.setRow"><a class="viewcode-back" href="../../modules_doc.html#cbmpy.PyscesStoich.StructMatrix.setRow">[docs]</a>    <span class="k">def</span> <span class="nf">setRow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assuming that the row index array is a permutation (full/subset)</span>
<span class="sd">        of a source label array by supplying that source to setRow it</span>
<span class="sd">        maps the row labels to ridx and creates self.row (row label list)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">row</span> <span class="o">=</span> <span class="p">[</span><span class="n">src</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ridx</span><span class="p">]</span></div>

<div class="viewcode-block" id="StructMatrix.setCol"><a class="viewcode-back" href="../../modules_doc.html#cbmpy.PyscesStoich.StructMatrix.setCol">[docs]</a>    <span class="k">def</span> <span class="nf">setCol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assuming that the col index array is a permutation (full/subset)</span>
<span class="sd">        of a source label array by supplying that src to setCol</span>
<span class="sd">        maps the row labels to cidx and creates self.col (col label list)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="p">[</span><span class="n">src</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cidx</span><span class="p">]</span></div>

<div class="viewcode-block" id="StructMatrix.getRowsByName"><a class="viewcode-back" href="../../modules_doc.html#cbmpy.PyscesStoich.StructMatrix.getRowsByName">[docs]</a>    <span class="k">def</span> <span class="nf">getRowsByName</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the rows referenced by label (&#39;s&#39;,&#39;x&#39;,&#39;d&#39;)&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">row</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">I need row labels&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">take</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">row</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">args</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Valid row labels are: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">row</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="StructMatrix.getColsByName"><a class="viewcode-back" href="../../modules_doc.html#cbmpy.PyscesStoich.StructMatrix.getColsByName">[docs]</a>    <span class="k">def</span> <span class="nf">getColsByName</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the columns referenced by label (&#39;s&#39;,&#39;x&#39;,&#39;d&#39;)&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">I need column labels&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">take</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">args</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Valid column labels are: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="StructMatrix.getLabels"><a class="viewcode-back" href="../../modules_doc.html#cbmpy.PyscesStoich.StructMatrix.getLabels">[docs]</a>    <span class="k">def</span> <span class="nf">getLabels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the matrix labels ([rows],[cols]) where axis=&#39;row&#39;/&#39;col&#39;/&#39;all&#39;&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;row&#39;</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">row</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;col&#39;</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span>
        <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span></div>

<div class="viewcode-block" id="StructMatrix.getIndexes"><a class="viewcode-back" href="../../modules_doc.html#cbmpy.PyscesStoich.StructMatrix.getIndexes">[docs]</a>    <span class="k">def</span> <span class="nf">getIndexes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the matrix indexes ([rows],[cols]) where axis=&#39;row&#39;/&#39;col&#39;/&#39;all&#39;&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;row&#39;</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ridx</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;col&#39;</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cidx</span>
        <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ridx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cidx</span></div>

    <span class="k">def</span> <span class="nf">getByIdx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">row</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ridx</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="si">%s</span><span class="s1"> is an invalid index&#39;</span> <span class="o">%</span> <span class="n">row</span>
        <span class="k">assert</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cidx</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="si">%s</span><span class="s1"> is an invalid index&#39;</span> <span class="o">%</span> <span class="n">col</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">getByName</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">row</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="si">%s</span><span class="s1"> is an invalid name&#39;</span> <span class="o">%</span> <span class="n">row</span>
        <span class="k">assert</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="si">%s</span><span class="s1"> is an invalid name&#39;</span> <span class="o">%</span> <span class="n">col</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">row</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">row</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">col</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">setByIdx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">row</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ridx</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="si">%s</span><span class="s1"> is an invalid index&#39;</span> <span class="o">%</span> <span class="n">row</span>
        <span class="k">assert</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cidx</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="si">%s</span><span class="s1"> is an invalid index&#39;</span> <span class="o">%</span> <span class="n">col</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

    <span class="k">def</span> <span class="nf">setByName</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">row</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="si">%s</span><span class="s1"> is an invalid name&#39;</span> <span class="o">%</span> <span class="n">row</span>
        <span class="k">assert</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="si">%s</span><span class="s1"> is an invalid name&#39;</span> <span class="o">%</span> <span class="n">col</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">row</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">row</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">col</span><span class="p">)]</span> <span class="o">=</span> <span class="n">val</span></div>

<div class="viewcode-block" id="MathArrayFunc"><a class="viewcode-back" href="../../modules_doc.html#cbmpy.PyscesStoich.MathArrayFunc">[docs]</a><span class="k">class</span> <span class="nc">MathArrayFunc</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A class of basic array functions some LAPACK based&quot;&quot;&quot;</span>

    <span class="n">__doc__</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;PySCeS array functions - used by Stoich&#39;&#39;&#39;</span>

    <span class="n">array_kind</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;i&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;l&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
    <span class="n">array_precision</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;i&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;l&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
    <span class="n">array_type</span> <span class="o">=</span> <span class="p">[[</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">]]</span>
    <span class="n">LinAlgError</span> <span class="o">=</span> <span class="s1">&#39;LinearAlgebraError&#39;</span>

<div class="viewcode-block" id="MathArrayFunc.commonType"><a class="viewcode-back" href="../../modules_doc.html#cbmpy.PyscesStoich.MathArrayFunc.commonType">[docs]</a>    <span class="k">def</span> <span class="nf">commonType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">*</span><span class="n">arrays</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        commonType(\*arrays)</span>

<span class="sd">        Numeric detect and set array precision (will be replaced with new scipy.core compatible code when ready)</span>

<span class="sd">        Arguments:</span>

<span class="sd">        \*arrays: input arrays</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kind</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1">#    precision = 0</span>
    <span class="c1">#   force higher precision in lite version</span>
        <span class="n">precision</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">char</span>
            <span class="n">kind</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">kind</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_kind</span><span class="p">[</span><span class="n">t</span><span class="p">])</span>
            <span class="n">precision</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">precision</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_precision</span><span class="p">[</span><span class="n">t</span><span class="p">])</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_type</span><span class="p">[</span><span class="n">kind</span><span class="p">][</span><span class="n">precision</span><span class="p">]</span></div>

<div class="viewcode-block" id="MathArrayFunc.castCopyAndTranspose"><a class="viewcode-back" href="../../modules_doc.html#cbmpy.PyscesStoich.MathArrayFunc.castCopyAndTranspose">[docs]</a>    <span class="k">def</span> <span class="nf">castCopyAndTranspose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="nb">type</span><span class="p">,</span> <span class="o">*</span><span class="n">arrays</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        castCopyAndTranspose(type, \*arrays)</span>

<span class="sd">        Cast numeric arrays to required type and transpose</span>

<span class="sd">        Arguments:</span>

<span class="sd">        type: the required type to cast to</span>
<span class="sd">        \*arrays: the arrays to be processed</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cast_arrays</span> <span class="o">=</span> <span class="p">()</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">typecode</span><span class="p">()</span> <span class="o">==</span> <span class="nb">type</span><span class="p">:</span>
                <span class="n">cast_arrays</span> <span class="o">=</span> <span class="n">cast_arrays</span> <span class="o">+</span> <span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">a</span><span class="p">)),)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cast_arrays</span> <span class="o">=</span> <span class="n">cast_arrays</span> <span class="o">+</span> <span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">type</span><span class="p">)),)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cast_arrays</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">cast_arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cast_arrays</span></div>

<div class="viewcode-block" id="MathArrayFunc.assertRank2"><a class="viewcode-back" href="../../modules_doc.html#cbmpy.PyscesStoich.MathArrayFunc.assertRank2">[docs]</a>    <span class="k">def</span> <span class="nf">assertRank2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">*</span><span class="n">arrays</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        assertRank2(\*arrays)</span>

<span class="sd">        Check that we are using a 2D array</span>

<span class="sd">        Arguments:</span>

<span class="sd">        \*arrays: input array(s)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">LinAlgError</span><span class="p">(</span><span class="s1">&#39;Array must be two-dimensional&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="MathArrayFunc.SwapCol"><a class="viewcode-back" href="../../modules_doc.html#cbmpy.PyscesStoich.MathArrayFunc.SwapCol">[docs]</a>    <span class="k">def</span> <span class="nf">SwapCol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">res_a</span><span class="p">,</span><span class="n">r1</span><span class="p">,</span><span class="n">r2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        SwapCol(res_a,r1,r2)</span>

<span class="sd">        Swap two columns using BLAS swap, arrays can be (or are upcast to) type double (d) or double complex (D).</span>
<span class="sd">        Returns the colswapped array</span>

<span class="sd">        Arguments:</span>

<span class="sd">        res_a: the input array</span>
<span class="sd">        r1: the first column to be swapped</span>
<span class="sd">        r2: the second column to be swapped</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_kind</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">commonType</span><span class="p">(</span><span class="n">res_a</span><span class="p">)]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>      <span class="c1"># brett 20041226 added complex support to swap</span>
            <span class="n">res_a</span> <span class="o">=</span> <span class="n">res_a</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;D&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">SwapColz</span><span class="p">(</span><span class="n">res_a</span><span class="p">,</span><span class="n">r1</span><span class="p">,</span><span class="n">r2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res_a</span> <span class="o">=</span> <span class="n">res_a</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">SwapCold</span><span class="p">(</span><span class="n">res_a</span><span class="p">,</span><span class="n">r1</span><span class="p">,</span><span class="n">r2</span><span class="p">)</span></div>


<div class="viewcode-block" id="MathArrayFunc.SwapRow"><a class="viewcode-back" href="../../modules_doc.html#cbmpy.PyscesStoich.MathArrayFunc.SwapRow">[docs]</a>    <span class="k">def</span> <span class="nf">SwapRow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">res_a</span><span class="p">,</span><span class="n">r1</span><span class="p">,</span><span class="n">r2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        SwapRow(res_a,r1,r2)</span>

<span class="sd">        Swaps two rows using BLAS swap, arrays can be (or are upcast to) type double (d) or double complex (D).</span>
<span class="sd">        Returns the rowswapped array.</span>

<span class="sd">        Arguments:</span>

<span class="sd">        res_a: the input array</span>
<span class="sd">        r1: the first row index to be swapped</span>
<span class="sd">        r2:  the second row index to be swapped</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_kind</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">commonType</span><span class="p">(</span><span class="n">res_a</span><span class="p">)]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>      <span class="c1"># brett 20041226 added complex support to swap</span>
            <span class="n">res_a</span> <span class="o">=</span> <span class="n">res_a</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;D&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">SwapRowz</span><span class="p">(</span><span class="n">res_a</span><span class="p">,</span><span class="n">r1</span><span class="p">,</span><span class="n">r2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res_a</span> <span class="o">=</span> <span class="n">res_a</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">SwapRowd</span><span class="p">(</span><span class="n">res_a</span><span class="p">,</span><span class="n">r1</span><span class="p">,</span><span class="n">r2</span><span class="p">)</span></div>

<div class="viewcode-block" id="MathArrayFunc.SwapElem"><a class="viewcode-back" href="../../modules_doc.html#cbmpy.PyscesStoich.MathArrayFunc.SwapElem">[docs]</a>    <span class="k">def</span> <span class="nf">SwapElem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">res_a</span><span class="p">,</span><span class="n">r1</span><span class="p">,</span><span class="n">r2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        SwapElem(res_a,r1,r2)</span>

<span class="sd">        Swaps two elements in a 1D vector</span>

<span class="sd">        Arguments:</span>

<span class="sd">        res_a: the input vector</span>
<span class="sd">        r1: index 1</span>
<span class="sd">        r2: index 2</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res_a</span><span class="p">[</span><span class="n">r1</span><span class="p">],</span><span class="n">res_a</span><span class="p">[</span><span class="n">r2</span><span class="p">]</span> <span class="o">=</span> <span class="n">res_a</span><span class="p">[</span><span class="n">r2</span><span class="p">],</span><span class="n">res_a</span><span class="p">[</span><span class="n">r1</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">res_a</span><span class="p">)</span></div>

<div class="viewcode-block" id="MathArrayFunc.SwapCold"><a class="viewcode-back" href="../../modules_doc.html#cbmpy.PyscesStoich.MathArrayFunc.SwapCold">[docs]</a>    <span class="k">def</span> <span class="nf">SwapCold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">res_a</span><span class="p">,</span><span class="n">c1</span><span class="p">,</span><span class="n">c2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        SwapCold(res_a,c1,c2)</span>

<span class="sd">        Swaps two double (d) columns in an array using BLAS DSWAP. Returns the colswapped array.</span>

<span class="sd">        Arguments:</span>

<span class="sd">        res_a: input array</span>
<span class="sd">        c1: column index 1</span>
<span class="sd">        c2: column index 2</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res_a</span> <span class="o">=</span> <span class="n">res_a</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">)</span>
        <span class="n">res_a</span><span class="p">[:,</span><span class="n">c1</span><span class="p">],</span><span class="n">res_a</span><span class="p">[:,</span><span class="n">c2</span><span class="p">]</span> <span class="o">=</span> <span class="n">myfblas</span><span class="o">.</span><span class="n">dswap</span><span class="p">(</span><span class="n">res_a</span><span class="p">[:,</span><span class="n">c1</span><span class="p">],</span><span class="n">res_a</span><span class="p">[:,</span><span class="n">c2</span><span class="p">])</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">res_a</span><span class="p">)</span></div>

<div class="viewcode-block" id="MathArrayFunc.SwapRowd"><a class="viewcode-back" href="../../modules_doc.html#cbmpy.PyscesStoich.MathArrayFunc.SwapRowd">[docs]</a>    <span class="k">def</span> <span class="nf">SwapRowd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">res_a</span><span class="p">,</span><span class="n">r1</span><span class="p">,</span><span class="n">r2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        SwapRowd(res_a,c1,c2)</span>

<span class="sd">        Swaps two double (d) rows in an array using BLAS DSWAP. Returns the rowswapped array.</span>

<span class="sd">        Arguments:</span>

<span class="sd">        res_a: input array</span>
<span class="sd">        c1: row index 1</span>
<span class="sd">        c2: row index 2</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res_a</span> <span class="o">=</span> <span class="n">res_a</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">)</span>
        <span class="n">res_a</span><span class="p">[</span><span class="n">r1</span><span class="p">,:],</span><span class="n">res_a</span><span class="p">[</span><span class="n">r2</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">myfblas</span><span class="o">.</span><span class="n">dswap</span><span class="p">(</span><span class="n">res_a</span><span class="p">[</span><span class="n">r1</span><span class="p">,:],</span><span class="n">res_a</span><span class="p">[</span><span class="n">r2</span><span class="p">,:])</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">res_a</span><span class="p">)</span></div>

<div class="viewcode-block" id="MathArrayFunc.SwapColz"><a class="viewcode-back" href="../../modules_doc.html#cbmpy.PyscesStoich.MathArrayFunc.SwapColz">[docs]</a>    <span class="k">def</span> <span class="nf">SwapColz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">res_a</span><span class="p">,</span><span class="n">c1</span><span class="p">,</span><span class="n">c2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        SwapColz(res_a,c1,c2)</span>

<span class="sd">        Swaps two double complex (D) columns in an array using BLAS ZSWAP. Returns the colswapped array.</span>

<span class="sd">        Arguments:</span>

<span class="sd">        res_a: input array</span>
<span class="sd">        c1: column index 1</span>
<span class="sd">        c2: column index 2</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res_a</span> <span class="o">=</span> <span class="n">res_a</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;D&#39;</span><span class="p">)</span>
        <span class="n">res_a</span><span class="p">[:,</span><span class="n">c1</span><span class="p">],</span><span class="n">res_a</span><span class="p">[:,</span><span class="n">c2</span><span class="p">]</span> <span class="o">=</span> <span class="n">myfblas</span><span class="o">.</span><span class="n">zswap</span><span class="p">(</span><span class="n">res_a</span><span class="p">[:,</span><span class="n">c1</span><span class="p">],</span><span class="n">res_a</span><span class="p">[:,</span><span class="n">c2</span><span class="p">])</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">res_a</span><span class="p">)</span></div>

<div class="viewcode-block" id="MathArrayFunc.SwapRowz"><a class="viewcode-back" href="../../modules_doc.html#cbmpy.PyscesStoich.MathArrayFunc.SwapRowz">[docs]</a>    <span class="k">def</span> <span class="nf">SwapRowz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">res_a</span><span class="p">,</span><span class="n">r1</span><span class="p">,</span><span class="n">r2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        SwapRowz(res_a,c1,c2)</span>

<span class="sd">        Swaps two double complex (D) rows in an array using BLAS ZSWAP. Returns the rowswapped array.</span>

<span class="sd">        Arguments:</span>

<span class="sd">        res_a: input array</span>
<span class="sd">        c1: row index 1</span>
<span class="sd">        c2: row index 2</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res_a</span> <span class="o">=</span> <span class="n">res_a</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;D&#39;</span><span class="p">)</span>
        <span class="n">res_a</span><span class="p">[</span><span class="n">r1</span><span class="p">,:],</span><span class="n">res_a</span><span class="p">[</span><span class="n">r2</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">myfblas</span><span class="o">.</span><span class="n">zswap</span><span class="p">(</span><span class="n">res_a</span><span class="p">[</span><span class="n">r1</span><span class="p">,:],</span><span class="n">res_a</span><span class="p">[</span><span class="n">r2</span><span class="p">,:])</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">res_a</span><span class="p">)</span></div>

<div class="viewcode-block" id="MathArrayFunc.MatrixFloatFix"><a class="viewcode-back" href="../../modules_doc.html#cbmpy.PyscesStoich.MathArrayFunc.MatrixFloatFix">[docs]</a>    <span class="k">def</span> <span class="nf">MatrixFloatFix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">mat</span><span class="p">,</span><span class="n">val</span><span class="o">=</span><span class="mf">1.e-15</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        MatrixFloatFix(mat,val=1.e-15)</span>

<span class="sd">        Clean an array removing any floating point artifacts defined as being smaller than a specified value.</span>
<span class="sd">        Processes an array inplace</span>

<span class="sd">        Arguments:</span>

<span class="sd">        mat: the input 2D array</span>
<span class="sd">        val [default=1.e-15]: the threshold value (effective zero)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">zero_vals</span> <span class="o">=</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">val</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">zero_vals</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">]:</span>
                    <span class="n">mat</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="c1">##  if abs(mat[x,y]) != 0.0 and abs(mat[x,y]) &lt; val:</span>
                    <span class="c1">##  mat[x,y] = round(mat[x,y])</span>
                    <span class="c1">##  if abs(mat[x,y]) &lt; val:</span>
                        <span class="c1">##  #mat[x,y] = round(mat[x,y])</span>
                        <span class="c1">##  mat[x,y] = 0.0</span>
        <span class="k">del</span> <span class="n">zero_vals</span></div>

<div class="viewcode-block" id="MathArrayFunc.MatrixValueCompare"><a class="viewcode-back" href="../../modules_doc.html#cbmpy.PyscesStoich.MathArrayFunc.MatrixValueCompare">[docs]</a>    <span class="k">def</span> <span class="nf">MatrixValueCompare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">matrix</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        MatrixValueCompare(matrix)</span>

<span class="sd">        Finds the largest/smallest abs(value) &gt; 0.0 in a matrix.</span>
<span class="sd">        Returns a tuple containing (smallest,largest) values</span>

<span class="sd">        Arguments:</span>

<span class="sd">        matrix: the input 2D array</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">val_B</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">val_S</span> <span class="o">=</span> <span class="mf">1.0e30</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">])</span> <span class="o">&gt;</span> <span class="nb">abs</span><span class="p">(</span><span class="n">val_B</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">])</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
                    <span class="n">val_B</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">])</span> <span class="o">&lt;</span> <span class="nb">abs</span><span class="p">(</span><span class="n">val_S</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">])</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
                    <span class="n">val_S</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">val_S</span><span class="p">,</span><span class="n">val_B</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Stoich"><a class="viewcode-back" href="../../modules_doc.html#cbmpy.PyscesStoich.Stoich">[docs]</a><span class="k">class</span> <span class="nc">Stoich</span><span class="p">(</span><span class="n">MathArrayFunc</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;PySCeS stoichiometric analysis class: initialized with a stoichiometric matrix N (input)&#39;&#39;&#39;</span>
    <span class="n">__stoichdiagmode__</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">__version__</span> <span class="o">=</span> <span class="n">__version__</span>
    <span class="n">__TimeFormat</span> <span class="o">=</span> <span class="s2">&quot;%H:%M:%S&quot;</span>
    <span class="n">USE_QR</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">info_moiety_conserve</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="nb">input</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize class variables&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nmatrix</span> <span class="o">=</span> <span class="nb">input</span>
        <span class="n">row</span><span class="p">,</span><span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmatrix</span><span class="o">.</span><span class="n">shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nmatrix_col</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">col</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nmatrix_row</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">row</span><span class="p">)))</span>

        <span class="c1">#Create a machine specific instance</span>
        <span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">MachAr</span>
        <span class="n">mach_spec</span> <span class="o">=</span> <span class="n">MachAr</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">stoichiometric_analysis_fp_zero</span> <span class="o">=</span> <span class="n">mach_spec</span><span class="o">.</span><span class="n">eps</span><span class="o">*</span><span class="mf">2.0e4</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stoichiometric_analysis_lu_precision</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stoichiometric_analysis_fp_zero</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stoichiometric_analysis_gj_precision</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stoichiometric_analysis_lu_precision</span><span class="o">*</span><span class="mf">10.0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">species</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reactions</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="Stoich.AnalyseK"><a class="viewcode-back" href="../../modules_doc.html#cbmpy.PyscesStoich.Stoich.AnalyseK">[docs]</a>    <span class="k">def</span> <span class="nf">AnalyseK</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        AnalyseK()</span>

<span class="sd">        Evaluate the stoichiometric matrix and calculate the nullspace using LU decomposition and backsubstitution .</span>
<span class="sd">        Generates the MCA K and Ko arrays and associated row and column vectors</span>

<span class="sd">        Arguments:</span>
<span class="sd">        None</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Calculating K matrix .&#39;</span><span class="p">,)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">info_flux_conserve</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1">#added 20020416 for conservation detection</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__stoichdiagmode__</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">KMATRIX</span><span class="se">\n</span><span class="s1">GetUpperMatrix: &#39;</span> <span class="o">+</span> <span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__TimeFormat</span><span class="p">))</span>

        <span class="n">p</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">row_vector</span><span class="p">,</span><span class="n">column_vector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GetUpperMatrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nmatrix</span><span class="p">)</span>
        <span class="c1">#p,u,row_vector,column_vector = self.GetUpperMatrixUsingQR(self.nmatrix)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__stoichdiagmode__</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">KMATRIX</span><span class="se">\n</span><span class="s1">ScalePivots: &#39;</span> <span class="o">+</span> <span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__TimeFormat</span><span class="p">))</span>

        <span class="n">unipiv_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ScalePivots</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__stoichdiagmode__</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">KMATRIX</span><span class="se">\n</span><span class="s1">BackSubstitution: &#39;</span> <span class="o">+</span> <span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__TimeFormat</span><span class="p">))</span>

        <span class="n">R_a</span><span class="p">,</span><span class="n">row_vector</span><span class="p">,</span><span class="n">column_vector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">BackSubstitution</span><span class="p">(</span><span class="n">unipiv_a</span><span class="p">,</span><span class="n">row_vector</span><span class="p">,</span><span class="n">column_vector</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__stoichdiagmode__</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">KMATRIX</span><span class="se">\n</span><span class="s1">K_split_R: &#39;</span> <span class="o">+</span> <span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__TimeFormat</span><span class="p">))</span>

        <span class="n">r_ipart</span><span class="p">,</span><span class="n">r_fpart</span><span class="p">,</span><span class="n">row_vector</span><span class="p">,</span><span class="n">column_vector</span><span class="p">,</span><span class="n">nullspace</span><span class="p">,</span><span class="n">r_fcolumns</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">info_flux_conserve</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">K_split_R</span><span class="p">(</span><span class="n">R_a</span><span class="p">,</span><span class="n">row_vector</span><span class="p">,</span><span class="n">column_vector</span><span class="p">)</span>
        <span class="c1"># Don&#39;t need anymore ... I think - brett 20051013</span>
<span class="c1">##        try:</span>
<span class="c1">##            self.MatrixFloatFix(nullspace,val=self.stoichiometric_analysis_lu_precision)</span>
<span class="c1">##        except Exception as e:</span>
<span class="c1">##            if self.__stoichdiagmode__:</span>
<span class="c1">##                print(&#39;Ignored (no K)&#39;,e) # brett 20050801</span>


        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__stoichdiagmode__</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">KMATRIX</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__TimeFormat</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">kmatrix</span> <span class="o">=</span> <span class="n">nullspace</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kmatrix_row</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">row_vector</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kmatrix_col</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">column_vector</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">kzeromatrix</span> <span class="o">=</span> <span class="n">r_fpart</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kzeromatrix_row</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">r_fcolumns</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kzeromatrix_col</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">column_vector</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; done.&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Stoich.AnalyseL"><a class="viewcode-back" href="../../modules_doc.html#cbmpy.PyscesStoich.Stoich.AnalyseL">[docs]</a>    <span class="k">def</span> <span class="nf">AnalyseL</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        AnalyseL()</span>

<span class="sd">        Evaluate the stoichiometric matrix and calculate the left nullspace using LU factorization and backsubstitution.</span>
<span class="sd">        Generates the MCA L, Lo, Nr and Conservation matrix and associated row and column vectors</span>

<span class="sd">        Arguments:</span>
<span class="sd">        None</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Calculating L matrix .&#39;</span><span class="p">,)</span>

        <span class="n">a</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nmatrix</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info_moiety_conserve</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1">#added 20020416 for conservation detection</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__stoichdiagmode__</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">LMATRIX</span><span class="se">\n</span><span class="s1">GetUpperMatrix: &#39;</span> <span class="o">+</span> <span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__TimeFormat</span><span class="p">))</span>


        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">USE_QR</span><span class="p">:</span>
            <span class="n">p</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">row_vector</span><span class="p">,</span><span class="n">column_vector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GetUpperMatrix</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">p</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">row_vector</span><span class="p">,</span><span class="n">column_vector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GetUpperMatrixUsingQR</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__stoichdiagmode__</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">LMATRIX</span><span class="se">\n</span><span class="s1">ScalePivots: &#39;</span> <span class="o">+</span> <span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__TimeFormat</span><span class="p">))</span>
        <span class="n">unipiv_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ScalePivots</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__stoichdiagmode__</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">LMATRIX</span><span class="se">\n</span><span class="s1">BackSubstitution: &#39;</span> <span class="o">+</span> <span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__TimeFormat</span><span class="p">))</span>

        <span class="n">R_a</span><span class="p">,</span><span class="n">row_vector</span><span class="p">,</span><span class="n">column_vector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">BackSubstitution</span><span class="p">(</span><span class="n">unipiv_a</span><span class="p">,</span><span class="n">row_vector</span><span class="p">,</span><span class="n">column_vector</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__stoichdiagmode__</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">LMATRIX</span><span class="se">\n</span><span class="s1">K_split_R: &#39;</span> <span class="o">+</span> <span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__TimeFormat</span><span class="p">))</span>

        <span class="n">r_ipart</span><span class="p">,</span><span class="n">consmatrix</span><span class="p">,</span><span class="n">cons_row_vector</span><span class="p">,</span><span class="n">cons_col_vector</span><span class="p">,</span><span class="n">lmatrix</span><span class="p">,</span><span class="n">lmatrix_row_vector</span><span class="p">,</span>\
        <span class="n">lmatrix_col_vector</span><span class="p">,</span><span class="n">lomatrix</span><span class="p">,</span><span class="n">lomatrix_row_vector</span><span class="p">,</span><span class="n">lomatrix_col_vector</span><span class="p">,</span><span class="n">nrmatrix</span><span class="p">,</span><span class="n">Nred_vector</span><span class="p">,</span>\
        <span class="n">Nred_vector_col</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">info_moiety_conserve</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L_split_R</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">R_a</span><span class="p">,</span><span class="n">row_vector</span><span class="p">,</span><span class="n">column_vector</span><span class="p">)</span>
        <span class="c1"># Don&#39;t need anymore ... i think - brett 20051013</span>
 <span class="c1">##       try:</span>
 <span class="c1">##           self.MatrixFloatFix(consmatrix,val=self.stoichiometric_analysis_lu_precision)</span>
 <span class="c1">##       except Exception as e:</span>
 <span class="c1">##           if self.__stoichdiagmode__:</span>
 <span class="c1">##               print(&#39;Ignored (no L)&#39;,e) # brett 20050801</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__stoichdiagmode__</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">LMATRIX</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__TimeFormat</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">lmatrix</span> <span class="o">=</span> <span class="n">lmatrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lmatrix_row</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">lmatrix_row_vector</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lmatrix_col</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">lmatrix_col_vector</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">lzeromatrix</span> <span class="o">=</span> <span class="n">lomatrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lzeromatrix_row</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">lomatrix_row_vector</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lzeromatrix_col</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">lomatrix_col_vector</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">conservation_matrix</span> <span class="o">=</span> <span class="n">consmatrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conservation_matrix_row</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">cons_row_vector</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conservation_matrix_col</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">cons_col_vector</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nrmatrix</span> <span class="o">=</span> <span class="n">nrmatrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nrmatrix_row</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">Nred_vector</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nrmatrix_col</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nmatrix_col</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; done.&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Stoich.PivotSort"><a class="viewcode-back" href="../../modules_doc.html#cbmpy.PyscesStoich.Stoich.PivotSort">[docs]</a>    <span class="k">def</span> <span class="nf">PivotSort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">row_vector</span><span class="p">,</span><span class="n">column_vector</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        PivotSort(a,row_vector,column_vector)</span>

<span class="sd">        This is a sorting routine that accepts a matrix and row/colum vectors</span>
<span class="sd">        and then sorts them so that: there are no zero rows (by swapping with first</span>
<span class="sd">        non-zero row) The abs(largest) pivots are moved onto the diagonal to maintain</span>
<span class="sd">        numerical stability. Row and column swaps are recorded in the tracking vectors.</span>

<span class="sd">        Arguments:</span>

<span class="sd">        a: the input array</span>
<span class="sd">        row_vector: row tracking vector</span>
<span class="sd">        column_vector: column tracking vector</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">commonType</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">row</span><span class="p">,</span><span class="n">col</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span>

        <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">min</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">z</span><span class="p">,</span><span class="n">z</span><span class="p">])</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">stoichiometric_analysis_lu_precision</span><span class="p">:</span>
                <span class="n">maxV</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stoichiometric_analysis_lu_precision</span>
                <span class="n">maxP</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
                <span class="n">zeroP</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>

                <span class="n">mList</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="nb">min</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">)):</span>
                    <span class="n">mList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="nb">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">:]))))</span>
                <span class="n">mVal</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="n">mRow</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="c1">#print(mList)</span>
                <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">mList</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">el</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">mVal</span><span class="p">:</span>
                        <span class="n">mVal</span> <span class="o">=</span> <span class="n">el</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">mRow</span> <span class="o">=</span> <span class="n">el</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__stoichdiagmode__</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">mVal&#39;</span><span class="p">,</span> <span class="n">mVal</span><span class="p">,</span> <span class="n">mRow</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">mRow</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">col</span><span class="p">):</span>
                        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">mRow</span><span class="p">,</span><span class="n">y</span><span class="p">])</span> <span class="o">&gt;</span> <span class="nb">abs</span><span class="p">(</span><span class="n">maxV</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">mRow</span><span class="p">,</span><span class="n">y</span><span class="p">])</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">stoichiometric_analysis_lu_precision</span><span class="p">:</span>
                            <span class="n">maxV</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">mRow</span><span class="p">,</span><span class="n">y</span><span class="p">]</span>
                            <span class="n">maxP</span> <span class="o">=</span> <span class="p">(</span><span class="n">mRow</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">zeroP</span> <span class="o">!=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="n">zeroP</span> <span class="o">!=</span> <span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">z</span><span class="p">)</span> <span class="ow">and</span> <span class="n">mRow</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__stoichdiagmode__</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  Swapping: &#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">z</span><span class="p">),</span> <span class="p">(</span><span class="n">zeroP</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">zeroP</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="mf">1.0</span><span class="p">)</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SwapRowd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">zeroP</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SwapCold</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">zeroP</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">row_vector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SwapElem</span><span class="p">(</span><span class="n">row_vector</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">zeroP</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">column_vector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SwapElem</span><span class="p">(</span><span class="n">column_vector</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">zeroP</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">elif</span> <span class="n">maxP</span> <span class="o">!=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="n">maxP</span> <span class="o">!=</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">),</span><span class="nb">min</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">))</span> <span class="ow">and</span> <span class="n">mRow</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__stoichdiagmode__</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  Swapping: &#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">z</span><span class="p">),</span> <span class="p">(</span><span class="n">maxP</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">maxP</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">a</span><span class="p">[</span><span class="n">z</span><span class="p">,</span><span class="n">z</span><span class="p">],</span> <span class="n">maxV</span><span class="p">)</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SwapRowd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">maxP</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SwapCold</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">maxP</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">row_vector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SwapElem</span><span class="p">(</span><span class="n">row_vector</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">maxP</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">column_vector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SwapElem</span><span class="p">(</span><span class="n">column_vector</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">maxP</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">row_vector</span><span class="p">,</span><span class="n">column_vector</span><span class="p">)</span></div>

<div class="viewcode-block" id="Stoich.PivotSort_initial"><a class="viewcode-back" href="../../modules_doc.html#cbmpy.PyscesStoich.Stoich.PivotSort_initial">[docs]</a>    <span class="k">def</span> <span class="nf">PivotSort_initial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">row_vector</span><span class="p">,</span><span class="n">column_vector</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        PivotSort_initial(a,row_vector,column_vector)</span>

<span class="sd">        This is a sorting routine that accepts a matrix and row/colum vectors</span>
<span class="sd">        and then sorts them so that: the abs(largest) pivots are moved onto the diagonal to maintain</span>
<span class="sd">        numerical stability i.e. the matrix diagonal is in descending max(abs(value)).</span>
<span class="sd">        Row and column swaps are recorded in the tracking vectors.</span>

<span class="sd">        Arguments:</span>

<span class="sd">        a: the input array</span>
<span class="sd">        row_vector: row tracking vector</span>
<span class="sd">        column_vector: column tracking vector</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># SAME AS THE ABOVE JUST DOES ALL VALUES NOT ONLY NON_ZERO ONES</span>
        <span class="c1"># brett 200500802</span>

        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">commonType</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">row</span><span class="p">,</span><span class="n">col</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span>

        <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">min</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">z</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">z</span><span class="p">,</span><span class="n">z</span><span class="p">])</span> <span class="o">&lt;</span> <span class="nb">abs</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">z</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">z</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">maxV</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stoichiometric_analysis_lu_precision</span>
                <span class="n">maxP</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
                <span class="n">zeroP</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
                <span class="n">mList</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="nb">min</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">)):</span>
                    <span class="n">mList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="nb">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">:]))))</span>
                <span class="n">mVal</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="n">mRow</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">mList</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">el</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">mVal</span><span class="p">:</span>
                        <span class="n">mVal</span> <span class="o">=</span> <span class="n">el</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">mRow</span> <span class="o">=</span> <span class="n">el</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__stoichdiagmode__</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">mVal&#39;</span><span class="p">,</span> <span class="n">mVal</span><span class="p">,</span> <span class="n">mRow</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">mRow</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">col</span><span class="p">):</span>
                        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">])</span> <span class="o">&gt;</span> <span class="nb">abs</span><span class="p">(</span><span class="n">maxV</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">])</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">stoichiometric_analysis_lu_precision</span><span class="p">:</span>
                            <span class="n">maxV</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">]</span>
                            <span class="n">maxP</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">maxP</span> <span class="o">!=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="n">maxP</span> <span class="o">!=</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">),</span><span class="nb">min</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">))</span> <span class="ow">and</span> <span class="n">maxP</span> <span class="o">!=</span> <span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">z</span><span class="p">):</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__stoichdiagmode__</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  Swapping: &#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">z</span><span class="p">),</span> <span class="p">(</span><span class="n">maxP</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">maxP</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">a</span><span class="p">[</span><span class="n">z</span><span class="p">,</span><span class="n">z</span><span class="p">],</span> <span class="n">maxV</span><span class="p">)</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SwapRowd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">maxP</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SwapCold</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">maxP</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">row_vector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SwapElem</span><span class="p">(</span><span class="n">row_vector</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">maxP</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">column_vector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SwapElem</span><span class="p">(</span><span class="n">column_vector</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">maxP</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">row_vector</span><span class="p">,</span><span class="n">column_vector</span><span class="p">)</span></div>


<div class="viewcode-block" id="Stoich.PLUfactorize"><a class="viewcode-back" href="../../modules_doc.html#cbmpy.PyscesStoich.Stoich.PLUfactorize">[docs]</a>    <span class="k">def</span> <span class="nf">PLUfactorize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">a_in</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        PLUfactorize(a_in)</span>

<span class="sd">        Performs an LU factorization using LAPACK D/ZGetrf. Now optimized for FLAPACK interface.</span>
<span class="sd">        Returns LU - combined factorization, IP - rowswap information and info - Getrf error control.</span>

<span class="sd">        Arguments:</span>

<span class="sd">        a_in: the matrix to be factorized</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">assertRank2</span><span class="p">(</span><span class="n">a_in</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">commonType</span><span class="p">(</span><span class="n">a_in</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">a_in</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">char</span> <span class="o">==</span> <span class="s1">&#39;D&#39;</span><span class="p">:</span>
            <span class="c1">#print(&#39;Complex matrix &#39; + a_in.typecode())</span>
            <span class="c1">##  a = copy.copy(scipy.transpose(a_in))</span>
            <span class="c1"># brett 201106 flapack optimize</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">a_in</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">a_in</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">char</span> <span class="o">==</span> <span class="s1">&#39;d&#39;</span><span class="p">:</span>
            <span class="c1">#print(&#39;Float matrix &#39; + a_in.typecode())</span>
            <span class="c1">##  a = copy.copy(scipy.transpose(a_in))</span>
            <span class="c1"># brett 201106 flapack optimize</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">a_in</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#print(&#39;Other matrix casting to double, was: &#39; + a_in.typecode())</span>
            <span class="c1">##  a = copy.copy(scipy.transpose(a_in).astype(&#39;d&#39;))</span>
            <span class="c1"># brett 201106 flapack optimize</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">a_in</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">)</span>
        <span class="n">Using_FLAPACK</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="c1"># brett 20110620 - clapack support is being removed from scipy going exclusively flapack now</span>
        <span class="c1"># brett 20041226 - protecting ourselves against flapack</span>
        <span class="c1">##  try:</span>
            <span class="c1">##  scipy.linalg.clapack.empty_module()</span>
            <span class="c1">##  Using_FLAPACK = 1</span>
            <span class="c1">##  print(&quot;Using FLAPACK&quot;)</span>
        <span class="c1">##  except:</span>
            <span class="c1">##  print(&quot;Using CLAPACK&quot;)</span>

        <span class="k">if</span> <span class="n">Using_FLAPACK</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_kind</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">getrf</span> <span class="o">=</span> <span class="n">myflapack</span><span class="o">.</span><span class="n">zgetrf</span> <span class="c1">#scipy flapack 20041226</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">getrf</span> <span class="o">=</span> <span class="n">myflapack</span><span class="o">.</span><span class="n">dgetrf</span> <span class="c1">#scipy flapack 20041226</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;FLAPACK error&quot;</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
        <span class="c1">##  else:</span>
            <span class="c1">##  try:</span>
                <span class="c1">##  if self.array_kind[t] == 1:</span>
                    <span class="c1">##  getrf = scipy.linalg.clapack.zgetrf #scipy clapack (ATLAS) 20030605</span>
                <span class="c1">##  else:</span>
                    <span class="c1">##  getrf = scipy.linalg.clapack.dgetrf #scipy clapack (ATLAS) 20030605</span>
            <span class="c1">##  except Exception as e:</span>
                <span class="c1">##  print(&quot;CLAPACK error&quot;, e)</span>

        <span class="k">if</span> <span class="n">Using_FLAPACK</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1">##  results = getrf(scipy.transpose(a)) # brett 20041226</span>
            <span class="n">results</span> <span class="o">=</span> <span class="n">getrf</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c1"># brett 201106</span>
        <span class="c1">##  else:</span>
            <span class="c1">##  # This is a $%^&amp;*( ... suddenly with latest cvs f2py getrf only accepts arrays</span>
            <span class="c1">##  # not vectors so this song and dance is necessary to fix this &#39;behaviour&#39;</span>
            <span class="c1">##  # as idiotic as it seems, we pad the vector with a zero row (no difference numerically)</span>
            <span class="c1">##  # run it through getrf and then strip it afterwards !@#$%^&amp;*() - brett 20050707</span>
            <span class="c1">##  if a.shape[0] == 1:</span>
                <span class="c1">##  tarr = scipy.zeros((a.shape[0]+1,a.shape[1]),&#39;d&#39;)</span>
                <span class="c1">##  tarr[0] = a[0]</span>

                <span class="c1">##  results = getrf(tarr) #scipy cblas (ATLAS) 20030506 -- this is normal</span>

                <span class="c1">##  results = list(results)</span>
                <span class="c1">##  results[0] = scipy.array([results[0][0]])</span>
                <span class="c1">##  results[1] = scipy.array([results[1][0]],&#39;i&#39;)</span>
                <span class="c1">##  results[2] = results[2]</span>
                <span class="c1">##  results = tuple(results)</span>
            <span class="c1">##  else:</span>
                <span class="c1">##  results = getrf(a) #scipy cblas (ATLAS) 20030506 -- this is normal</span>

        <span class="n">results</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">results</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Argument &#39;</span><span class="p">,</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;info&#39;</span><span class="p">],</span> <span class="s1">&#39; had an illegal value&#39;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">LinAlgError</span>
        <span class="k">elif</span> <span class="n">results</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">if</span> <span class="n">Using_FLAPACK</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># brett 20041226</span>
        <span class="c1">##  else:</span>
            <span class="c1">##  result = scipy.transpose(results[0]) # -- this is normal</span>

        <span class="n">badlist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">])</span> <span class="o">!=</span> <span class="mf">0.0</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">])</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">stoichiometric_analysis_lu_precision</span><span class="p">:</span>
                    <span class="n">result</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>        <span class="c1"># gets rid of the -0.0 irritation</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">badlist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">):</span> <span class="c1"># catch 1st float on a pivot</span>
                        <span class="n">badlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">badlist</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">results</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">badlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span> <span class="c1"># 20040423 if float was on a pivot - refactorize</span>

        <span class="k">return</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="n">results</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">results</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="c1">#scipy cblas (ATLAS?) 20030506</span></div>


    <span class="c1">##  def PLUfactorizeOLD(self,a_in):</span>
        <span class="c1">##  &quot;&quot;&quot;</span>
        <span class="c1">##  PLUfactorize(a_in) OLD PRE SCIPY 0.10 uses clapack</span>

        <span class="c1">##  Performs an LU factorization using LAPACK D/ZGetrf.</span>
        <span class="c1">##  Returns LU - combined factorization, IP - rowswap information and info - Getrf error control.</span>

        <span class="c1">##  Arguments:</span>

        <span class="c1">##  a_in: the matrix to be factorized</span>

        <span class="c1">##  &quot;&quot;&quot;</span>
        <span class="c1">##  print(&#39;.&#39;,)</span>

        <span class="c1">##  self.assertRank2(a_in)</span>
        <span class="c1">##  t = self.commonType(a_in)</span>
        <span class="c1">##  if a_in.dtype.char == &#39;D&#39;:</span>
            <span class="c1">##  #print &#39;Complex matrix &#39; + a_in.typecode()</span>
            <span class="c1">##  a = copy.copy(scipy.transpose(a_in))</span>
        <span class="c1">##  elif a_in.dtype.char == &#39;d&#39;:</span>
            <span class="c1">##  #print &#39;Float matrix &#39; + a_in.typecode()</span>
            <span class="c1">##  a = copy.copy(scipy.transpose(a_in))</span>
        <span class="c1">##  else:</span>
            <span class="c1">##  #print &#39;Other matrix casting to double, was: &#39; + a_in.typecode()</span>
            <span class="c1">##  a = copy.copy(scipy.transpose(a_in).astype(&#39;d&#39;))</span>
        <span class="c1">##  Using_FLAPACK = 0</span>
        <span class="c1">##  # brett 20041226 - protecting ourselves against flapack</span>
        <span class="c1">##  try:</span>
            <span class="c1">##  scipy.linalg.clapack.empty_module()</span>
            <span class="c1">##  Using_FLAPACK = 1</span>
            <span class="c1">##  print &quot;Using FLAPACK&quot;</span>
        <span class="c1">##  except:</span>
            <span class="c1">##  print &quot;Using CLAPACK&quot;</span>

        <span class="c1">##  if Using_FLAPACK == 1:</span>
            <span class="c1">##  try:</span>
                <span class="c1">##  if self.array_kind[t] == 1:</span>
                    <span class="c1">##  getrf = myflapack.zgetrf #scipy flapack 20041226</span>
                <span class="c1">##  else:</span>
                    <span class="c1">##  getrf = myflapack.dgetrf #scipy flapack 20041226</span>
            <span class="c1">##  except Exception as e:</span>
                <span class="c1">##  print &quot;FLAPACK error&quot;, e</span>
        <span class="c1">##  else:</span>
            <span class="c1">##  try:</span>
                <span class="c1">##  if self.array_kind[t] == 1:</span>
                    <span class="c1">##  getrf = scipy.linalg.clapack.zgetrf #scipy clapack (ATLAS) 20030605</span>
                <span class="c1">##  else:</span>
                    <span class="c1">##  getrf = scipy.linalg.clapack.dgetrf #scipy clapack (ATLAS) 20030605</span>
            <span class="c1">##  except Exception as e:</span>
                <span class="c1">##  print &quot;CLAPACK error&quot;, e</span>

        <span class="c1">##  if Using_FLAPACK == 1:</span>
            <span class="c1">##  results = getrf(scipy.transpose(a)) # brett 20041226</span>
        <span class="c1">##  else:</span>
            <span class="c1">##  # This is a $%^&amp;*( ... suddenly with latest cvs f2py getrf only accepts arrays</span>
            <span class="c1">##  # not vectors so this song and dance is necessary to fix this &#39;behaviour&#39;</span>
            <span class="c1">##  # as idiotic as it seems, we pad the vector with a zero row (no difference numerically)</span>
            <span class="c1">##  # run it through getrf and then strip it afterwards !@#$%^&amp;*() - brett 20050707</span>
            <span class="c1">##  if a.shape[0] == 1:</span>
                <span class="c1">##  tarr = scipy.zeros((a.shape[0]+1,a.shape[1]),&#39;d&#39;)</span>
                <span class="c1">##  tarr[0] = a[0]</span>

                <span class="c1">##  results = getrf(tarr) #scipy cblas (ATLAS) 20030506 -- this is normal</span>

                <span class="c1">##  results = list(results)</span>
                <span class="c1">##  results[0] = scipy.array([results[0][0]])</span>
                <span class="c1">##  results[1] = scipy.array([results[1][0]],&#39;i&#39;)</span>
                <span class="c1">##  results[2] = results[2]</span>
                <span class="c1">##  results = tuple(results)</span>
            <span class="c1">##  else:</span>
                <span class="c1">##  results = getrf(a) #scipy cblas (ATLAS) 20030506 -- this is normal</span>

        <span class="c1">##  results = list(results)</span>

        <span class="c1">##  if results[2] &lt; 0:</span>
            <span class="c1">##  print(&#39;Argument &#39;, results[&#39;info&#39;], &#39; had an illegal value&#39;)</span>
            <span class="c1">##  raise LinAlgError</span>
        <span class="c1">##  elif results[2] &gt; 0:</span>
            <span class="c1">##  pass</span>

        <span class="c1">##  if Using_FLAPACK == 1:</span>
            <span class="c1">##  result = results[0] # brett 20041226</span>
        <span class="c1">##  else:</span>
            <span class="c1">##  result = scipy.transpose(results[0]) # -- this is normal</span>


        <span class="c1">##  badlist = []</span>
        <span class="c1">##  for x in range(result.shape[0]):</span>
            <span class="c1">##  for y in range(result.shape[1]):</span>
                <span class="c1">##  if abs(result[x,y]) != 0.0 and abs(result[x,y]) &lt; self.stoichiometric_analysis_lu_precision:</span>
                    <span class="c1">##  result[x,y] = 0.0        # gets rid of the -0.0 irritation</span>
                    <span class="c1">##  if len(badlist) == 0 and (x,y) == (x,x): # catch 1st float on a pivot</span>
                        <span class="c1">##  badlist.append(x)</span>
        <span class="c1">##  if len(badlist) != 0:</span>
            <span class="c1">##  results[2] = badlist[0]-1 # 20040423 if float was on a pivot - refactorize</span>

        <span class="c1">##  return(result,results[1],results[2]) #scipy cblas (ATLAS?) 20030506</span>

<div class="viewcode-block" id="Stoich.SplitLU"><a class="viewcode-back" href="../../modules_doc.html#cbmpy.PyscesStoich.Stoich.SplitLU">[docs]</a>    <span class="k">def</span> <span class="nf">SplitLU</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">plu</span><span class="p">,</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        SplitLU(plu,row,col,t)</span>

<span class="sd">        PLU takes the combined LU factorization computed by PLUfactorize and extracts the upper matrix.</span>
<span class="sd">        Returns U.</span>

<span class="sd">        Arguments:</span>

<span class="sd">        plu: LU factorization</span>
<span class="sd">        row: row tracking vector</span>
<span class="sd">        col: column tracking vector</span>
<span class="sd">        t [default=None)]: typecode argument (currently not used)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__stoichdiagmode__</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">cl</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">min</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">)):</span>
            <span class="n">plu</span><span class="p">[</span><span class="n">cl</span><span class="o">+</span><span class="mi">1</span><span class="p">:,</span><span class="n">cl</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">return</span> <span class="n">plu</span></div>

<div class="viewcode-block" id="Stoich.GetUpperMatrix"><a class="viewcode-back" href="../../modules_doc.html#cbmpy.PyscesStoich.Stoich.GetUpperMatrix">[docs]</a>    <span class="k">def</span> <span class="nf">GetUpperMatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">a</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        GetUpperMatrix(a)</span>

<span class="sd">        Core analysis algorithm; an input is preconditioned using PivotSort_initial and then cycles of PLUfactorize and</span>
<span class="sd">        PivotSort are run until the factorization is completed. During this process the matrix is reordered by</span>
<span class="sd">        column swaps which emulates a full pivoting LU factorization. Returns the pivot matrix P, upper factorization U</span>
<span class="sd">        as well as the row/col tracking vectors.</span>

<span class="sd">        Arguments:</span>

<span class="sd">        a: a stoichiometric matrix</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,)</span>

        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">commonType</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">row</span><span class="p">,</span><span class="n">col</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1"># this is a test brett 20050802</span>
        <span class="n">row_vector</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="nb">range</span><span class="p">(</span><span class="n">row</span><span class="p">)))</span>
        <span class="n">column_vector</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="nb">range</span><span class="p">(</span><span class="n">col</span><span class="p">)))</span>
        <span class="n">a</span><span class="p">,</span><span class="n">row_vector</span><span class="p">,</span><span class="n">column_vector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">PivotSort_initial</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">row_vector</span><span class="p">,</span><span class="n">column_vector</span><span class="p">)</span>

        <span class="c1">#18/09/2000 PLUfactorize included in self.GetUpperMatrix</span>
        <span class="n">a</span><span class="p">,</span><span class="n">ip</span><span class="p">,</span><span class="n">info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">PLUfactorize</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

        <span class="c1"># get U from getrf&#39;s PLU</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__stoichdiagmode__</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>
        <span class="n">upper_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SplitLU</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>

        <span class="n">p_out</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">min</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">!=</span> <span class="n">ip</span><span class="p">[</span><span class="n">x</span><span class="p">]:</span>
                <span class="n">p_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SwapRowd</span><span class="p">(</span><span class="n">p_out</span><span class="p">,</span><span class="n">x</span><span class="p">,(</span><span class="n">ip</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
                <span class="n">row_vector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SwapElem</span><span class="p">(</span><span class="n">row_vector</span><span class="p">,</span><span class="n">x</span><span class="p">,(</span><span class="n">ip</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>

        <span class="sd">&#39;&#39;&#39;31/08/2000 Added to try to make sure that pivots exist only on the upper left side of the matrix</span>
<span class="sd">        max(abs(upper_out[x,:])) used instead of abs(max(upper_out[x,:])) otherwise for rows where</span>
<span class="sd">        all elements &lt; 0 zero is maximum, this way the max of positive values is used&#39;&#39;&#39;</span>

        <span class="n">upper_out</span><span class="p">,</span><span class="n">row_vector</span><span class="p">,</span><span class="n">column_vector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">PivotSort</span><span class="p">(</span><span class="n">upper_out</span><span class="p">,</span><span class="n">row_vector</span><span class="p">,</span><span class="n">column_vector</span><span class="p">)</span>


        <span class="sd">&#39;&#39;&#39;20/09/2000 This bit sorts out the echelon matrix by running (if needed) cycles of</span>
<span class="sd">        self.PLUfactorize, self.GetUpperMatrix, and pivsort until only a staircase matrix remains. It uses both the error</span>
<span class="sd">        generated by self.PLUfactorize(info) and go_flag to control itself&#39;&#39;&#39;</span>

        <span class="k">if</span> <span class="n">info</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1">#Here we check to see if the error is not in the last or reduced-last column if it is - exit</span>
    <span class="c1">#        go_flag = &#39;yes&#39; # 2001/04/26 changed for Python21 and future compatibility</span>
            <span class="n">go_flag</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">min</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">)):</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">upper_out</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">])</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">stoichiometric_analysis_lu_precision</span><span class="p">:</span>
                    <span class="n">pos_holder</span> <span class="o">=</span> <span class="n">x</span>
            <span class="k">if</span> <span class="n">pos_holder</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">info</span> <span class="ow">and</span> <span class="n">pos_holder</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">row</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">upper_out</span><span class="p">[</span><span class="n">pos_holder</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,:]))</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">stoichiometric_analysis_lu_precision</span><span class="p">:</span>
    <span class="c1">#                go_flag = &#39;no&#39; # 2001/04/26 changed for Python21 and future compatibility</span>
                    <span class="n">go_flag</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="n">pos_holder</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">info</span> <span class="ow">and</span> <span class="n">pos_holder</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="nb">min</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">):</span>
    <span class="c1">#            go_flag = &#39;no&#39; # 2001/04/26 changed for Python21 and future compatibility</span>
                <span class="n">go_flag</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1">#        while info &gt; 0 and go_flag == &#39;yes&#39;: # 2001/04/26 changed for Python21 and future compatibility</span>
            <span class="k">while</span> <span class="n">info</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">go_flag</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1">#sort</span>
                <span class="c1">#upper_out,row_vector,column_vector = pivot_sort2k5(upper_out,row_vector,column_vector)</span>
                <span class="n">upper_out</span><span class="p">,</span><span class="n">row_vector</span><span class="p">,</span><span class="n">column_vector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">PivotSort</span><span class="p">(</span><span class="n">upper_out</span><span class="p">,</span><span class="n">row_vector</span><span class="p">,</span><span class="n">column_vector</span><span class="p">)</span>
                <span class="c1">#PLUfactorize</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__stoichdiagmode__</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; Echelon: &#39;</span> <span class="o">+</span> <span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__TimeFormat</span><span class="p">),</span> <span class="s1">&#39;(&#39;</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span><span class="s1">&#39;)&#39;</span><span class="p">)</span>
                <span class="n">upper_out</span><span class="p">,</span><span class="n">ip</span><span class="p">,</span><span class="n">info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">PLUfactorize</span><span class="p">(</span><span class="n">upper_out</span><span class="p">)</span>

                <span class="c1"># get U from getrf&#39;s PLU</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__stoichdiagmode__</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>
                <span class="n">upper_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SplitLU</span><span class="p">(</span><span class="n">upper_out</span><span class="p">,</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>

                <span class="c1">#realign row vector and permutation matrix if necessary</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">min</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">!=</span> <span class="n">ip</span><span class="p">[</span><span class="n">x</span><span class="p">]:</span>
                        <span class="n">p_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SwapRowd</span><span class="p">(</span><span class="n">p_out</span><span class="p">,</span><span class="n">x</span><span class="p">,(</span><span class="n">ip</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
                        <span class="n">row_vector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SwapElem</span><span class="p">(</span><span class="n">row_vector</span><span class="p">,</span><span class="n">x</span><span class="p">,(</span><span class="n">ip</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
                <span class="c1">#test if we can exit -- same criteria as before</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">min</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">upper_out</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">])</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">stoichiometric_analysis_lu_precision</span><span class="p">:</span>
                        <span class="n">pos_holder</span> <span class="o">=</span> <span class="n">x</span>
                <span class="k">if</span> <span class="n">pos_holder</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">info</span> <span class="ow">and</span> <span class="n">pos_holder</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">row</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">upper_out</span><span class="p">[</span><span class="n">pos_holder</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,:]))</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">stoichiometric_analysis_lu_precision</span><span class="p">:</span>
    <span class="c1">#                    go_flag = &#39;no&#39; # 2001/04/26 changed for Python21 and future compatibility</span>
                        <span class="n">go_flag</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">elif</span> <span class="n">pos_holder</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">info</span> <span class="ow">and</span> <span class="n">pos_holder</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="nb">min</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">):</span>
    <span class="c1">#                go_flag = &#39;no&#39; # 2001/04/26 changed for Python21 and future compatibility</span>
                    <span class="n">go_flag</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="sd">&#39;&#39;&#39;This bit will get rid of any zero rows so that we will hopefully only have to work with a</span>
<span class="sd">        reduced matrix after this, for completeness the row_vector will also be sliced&#39;&#39;&#39;</span>

        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">min</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">upper_out</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">])</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">stoichiometric_analysis_lu_precision</span><span class="p">:</span>
                <span class="n">pos_holder</span> <span class="o">=</span> <span class="n">x</span>

        <span class="n">upper_out_r</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">pos_holder</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span><span class="n">col</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="n">upper_out_r</span> <span class="o">=</span> <span class="n">upper_out</span><span class="p">[:</span><span class="n">pos_holder</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,:]</span>
        <span class="n">row_vector_r</span> <span class="o">=</span> <span class="n">row_vector</span><span class="p">[:</span><span class="n">pos_holder</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span><span class="p">(</span><span class="n">p_out</span><span class="p">,</span><span class="n">upper_out_r</span><span class="p">,</span><span class="n">row_vector_r</span><span class="p">,</span><span class="n">column_vector</span><span class="p">)</span></div>


<div class="viewcode-block" id="Stoich.GetUpperMatrixUsingQR"><a class="viewcode-back" href="../../modules_doc.html#cbmpy.PyscesStoich.Stoich.GetUpperMatrixUsingQR">[docs]</a>    <span class="k">def</span> <span class="nf">GetUpperMatrixUsingQR</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">a</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        GetUpperMatrix(a)</span>

<span class="sd">        Core analysis algorithm; an input is preconditioned using PivotSort_initial and then cycles of PLUfactorize and</span>
<span class="sd">        PivotSort are run until the factorization is completed. During this process the matrix is reordered by</span>
<span class="sd">        column swaps which emulates a full pivoting LU factorization. Returns the pivot matrix P, upper factorization U</span>
<span class="sd">        as well as the row/col tracking vectors.</span>

<span class="sd">        Arguments:</span>

<span class="sd">        a: a stoichiometric matrix</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,)</span>

        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">commonType</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">row</span><span class="p">,</span><span class="n">col</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1"># this is a test brett 20050802</span>
        <span class="n">row_vector</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="nb">range</span><span class="p">(</span><span class="n">row</span><span class="p">)))</span>
        <span class="n">column_vector</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="nb">range</span><span class="p">(</span><span class="n">col</span><span class="p">)))</span>
        <span class="c1">##  a,row_vector,column_vector = self.PivotSort(a,row_vector,column_vector)</span>
        <span class="n">a</span><span class="p">,</span><span class="n">row_vector</span><span class="p">,</span><span class="n">column_vector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">PivotSort_initial</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">row_vector</span><span class="p">,</span><span class="n">column_vector</span><span class="p">)</span>


        <span class="n">Q</span><span class="p">,</span><span class="n">upper_out</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">MatrixFloatFix</span><span class="p">(</span><span class="n">upper_out</span><span class="p">,</span><span class="n">val</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stoichiometric_analysis_lu_precision</span><span class="o">*</span><span class="mf">10.0</span><span class="p">)</span>


        <span class="sd">&#39;&#39;&#39;This bit will get rid of any zero rows so that we will hopefully only have to work with a</span>
<span class="sd">        reduced matrix after this, for completeness the row_vector will also be sliced&#39;&#39;&#39;</span>

        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">min</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">upper_out</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">])</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">stoichiometric_analysis_lu_precision</span><span class="p">:</span>
                <span class="n">pos_holder</span> <span class="o">=</span> <span class="n">x</span>


        <span class="n">upper_out_r</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">pos_holder</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span><span class="n">col</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="n">p_out</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">upper_out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="p">[</span><span class="mf">1.0</span><span class="p">])</span>
        <span class="n">upper_out_r</span> <span class="o">=</span> <span class="n">upper_out</span><span class="p">[:</span><span class="n">pos_holder</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,:]</span>
        <span class="n">row_vector_r</span> <span class="o">=</span> <span class="n">row_vector</span><span class="p">[:</span><span class="n">pos_holder</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span><span class="p">(</span><span class="n">p_out</span><span class="p">,</span><span class="n">upper_out_r</span><span class="p">,</span><span class="n">row_vector_r</span><span class="p">,</span><span class="n">column_vector</span><span class="p">)</span></div>

<div class="viewcode-block" id="Stoich.ScalePivots"><a class="viewcode-back" href="../../modules_doc.html#cbmpy.PyscesStoich.Stoich.ScalePivots">[docs]</a>    <span class="k">def</span> <span class="nf">ScalePivots</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">a_one</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        ScalePivots(a_one)</span>

<span class="sd">        Given an upper triangular matrix U, this method scales the diagonal (pivot values) to one.</span>

<span class="sd">        Arguments:</span>

<span class="sd">        a_one: an upper triangular matrix U</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,)</span>

        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">commonType</span><span class="p">(</span><span class="n">a_one</span><span class="p">)</span>
        <span class="n">row</span><span class="p">,</span><span class="n">col</span> <span class="o">=</span> <span class="n">a_one</span><span class="o">.</span><span class="n">shape</span>

        <span class="sd">&#39;&#39;&#39;13/09/2000 We now assume that the matrix has the correct shape ie. the pivots are in a</span>
<span class="sd">        perfect staircase&#39;&#39;&#39;</span>

        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">row</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">a_one</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">])</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span> <span class="c1"># ths is to prevent NAN&#39;s when FixFloat zeros a supersmall pivot</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="nb">abs</span><span class="p">(</span><span class="n">a_one</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">])</span> <span class="o">!=</span> <span class="mf">1.0</span><span class="p">:</span>
                <span class="n">a_one</span><span class="p">[</span><span class="n">x</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">a_one</span><span class="p">[</span><span class="n">x</span><span class="p">,:]</span><span class="o">/</span><span class="nb">abs</span><span class="p">(</span><span class="n">a_one</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">a_one</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">a_one</span><span class="p">[</span><span class="n">x</span><span class="p">,:]</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">a_one</span><span class="p">[</span><span class="n">x</span><span class="p">,:])</span>
        <span class="k">return</span><span class="p">(</span><span class="n">a_one</span><span class="p">)</span></div>


<div class="viewcode-block" id="Stoich.BackSubstitution"><a class="viewcode-back" href="../../modules_doc.html#cbmpy.PyscesStoich.Stoich.BackSubstitution">[docs]</a>    <span class="k">def</span> <span class="nf">BackSubstitution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">res_a</span><span class="p">,</span><span class="n">row_vector</span><span class="p">,</span><span class="n">column_vector</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        BackSubstitution(res_a,row_vector,column_vector)</span>

<span class="sd">        Jordan reduction of a scaled upper triangular matrix. The returned array is now in the form [I R] and can</span>
<span class="sd">        be used for nullspace determination. Modified row and column tracking vetors are also returned.</span>

<span class="sd">        Arguments:</span>

<span class="sd">        res_a: unitary pivot upper triangular matrix</span>
<span class="sd">        row_vector: row tracking vector</span>
<span class="sd">        column_vector: column tracking vector</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,)</span>

        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">commonType</span><span class="p">(</span><span class="n">res_a</span><span class="p">)</span>
        <span class="n">row</span><span class="p">,</span><span class="n">col</span> <span class="o">=</span> <span class="n">res_a</span><span class="o">.</span><span class="n">shape</span>

        <span class="sd">&#39;&#39;&#39;13/09/2000 removed the copy thing, and eliminated the divnumb variable. Because we</span>
<span class="sd">        are now working with a row reduced matrix upward elimination only works on the pivot cols&#39;&#39;&#39;</span>

        <span class="c1"># old back substitution circa 2000! brett - 20050801</span>
        <span class="c1">##  bigF = 0</span>
        <span class="c1">##  if max(res_a.shape) &gt; 500:</span>
            <span class="c1">##  bigF = 1</span>
        <span class="c1">##  for y in range (min(row,col)-1,-1,-1):</span>
            <span class="c1">##  if bigF and self.__stoichdiagmode__:</span>
                <span class="c1">##  print(&#39;.&#39;,)</span>
            <span class="c1">##  for x in range (min(row,col)-2,-1,-1):</span>
                <span class="c1">##  z = x + 1</span>
                <span class="c1">##  while z &lt; min(row,col):</span>
                    <span class="c1">##  if abs(res_a[x,y]) &gt; self.stoichiometric_analysis_gj_precision and abs(res_a[z,y]) &gt; self.stoichiometric_analysis_gj_precision:</span>
                        <span class="c1">##  res_a[x,:] = res_a[x,:] - res_a[z,:]*(res_a[x,y]/res_a[z,y])</span>
                        <span class="c1">##  z = z + 1</span>
                        <span class="c1">##  continue</span>
                    <span class="c1">##  else:</span>
                        <span class="c1">##  z = z + 1</span>

        <span class="c1"># new back substitution</span>
        <span class="c1"># right looking algorithm that uses array slicing speeds up as it moves down the pivots</span>
        <span class="c1"># this algorithm is at least 3X as fast as the old one for a large system - brett 20050805</span>
        <span class="n">bigF</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="n">res_a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">500</span><span class="p">:</span>
            <span class="n">bigF</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">bigF</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">__stoichdiagmode__</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,)</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="nb">min</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">)):</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">res_a</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">])</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">stoichiometric_analysis_lu_precision</span><span class="p">:</span>
                    <span class="n">res_a</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:]</span> <span class="o">=</span> <span class="n">res_a</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:]</span><span class="o">-</span><span class="p">(</span><span class="n">res_a</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">]</span><span class="o">*</span><span class="n">res_a</span><span class="p">[</span><span class="n">y</span><span class="p">,</span><span class="n">y</span><span class="p">:])</span>

        <span class="c1"># $%^&amp;* wtf is this for??? brett - 20050801 (besides cleaning fp wierdness ... nothing ;-)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">MatrixFloatFix</span><span class="p">(</span><span class="n">res_a</span><span class="p">,</span><span class="n">val</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stoichiometric_analysis_gj_precision</span><span class="p">)</span>
        <span class="n">res_a</span><span class="p">,</span><span class="n">row_vector</span><span class="p">,</span><span class="n">column_vector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">PivotSort</span><span class="p">(</span><span class="n">res_a</span><span class="p">,</span><span class="n">row_vector</span><span class="p">,</span><span class="n">column_vector</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">res_a</span><span class="p">,</span><span class="n">row_vector</span><span class="p">,</span><span class="n">column_vector</span><span class="p">)</span></div>


<div class="viewcode-block" id="Stoich.K_split_R"><a class="viewcode-back" href="../../modules_doc.html#cbmpy.PyscesStoich.Stoich.K_split_R">[docs]</a>    <span class="k">def</span> <span class="nf">K_split_R</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">R_a</span><span class="p">,</span><span class="n">row_vector</span><span class="p">,</span><span class="n">column_vector</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        K_split_R(R_a,row_vector,column_vector)</span>

<span class="sd">        Using the R factorized form of the stoichiometric matrix we now form the K and Ko matrices. Returns</span>
<span class="sd">        the r_ipart,Komatrix,Krow,Kcolumn,Kmatrix,Korow,info</span>

<span class="sd">        Arguments:</span>

<span class="sd">        R_a: the Gauss-Jordan reduced stoichiometric matrix</span>
<span class="sd">        row_vector: row tracking vector</span>
<span class="sd">        column_vector: column tracking vector</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,)</span>

        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">commonType</span><span class="p">(</span><span class="n">R_a</span><span class="p">)</span>
        <span class="n">row</span><span class="p">,</span><span class="n">col</span> <span class="o">=</span> <span class="n">R_a</span><span class="o">.</span><span class="n">shape</span>

        <span class="sd">&#39;&#39;&#39;14/09/2000 Seeing as we now should have a perfect staircase in a reduced matrix we do</span>
<span class="sd">        not have to search for the last pivot it will exist at min(row,col)-1 so the pos_holder</span>
<span class="sd">        finding code has been removed (actually moved into self.GetUpperMatrix)&#39;&#39;&#39;</span>

        <span class="n">pos_holder</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="sd">&#39;&#39;&#39;This bit extracts the identity part from R (future note this could be replaced by an I matrix formed by min(row,col))&#39;&#39;&#39;</span>

        <span class="n">r_ipart</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">pos_holder</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span><span class="n">pos_holder</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="n">r_ipart</span> <span class="o">=</span> <span class="n">R_a</span><span class="p">[:</span><span class="n">pos_holder</span><span class="o">+</span><span class="mi">1</span><span class="p">,:</span><span class="n">pos_holder</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">row_i</span><span class="p">,</span><span class="n">col_i</span> <span class="o">=</span> <span class="n">r_ipart</span><span class="o">.</span><span class="n">shape</span>

        <span class="sd">&#39;&#39;&#39;If there are free variables, then this bit will extract them and form the row/col vectors&#39;&#39;&#39;</span>

        <span class="n">empty_rf</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">K_switch</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1">#added 20020416 class attribute for conservation detection 0 = none, 1 = exists</span>

        <span class="k">if</span> <span class="n">col</span> <span class="o">-</span> <span class="n">col_i</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">stoichiometric_analysis_fp_zero</span><span class="p">:</span>
            <span class="n">r_fpart</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">pos_holder</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span><span class="n">col</span> <span class="o">-</span> <span class="p">(</span><span class="n">pos_holder</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="n">r_fpart</span> <span class="o">=</span> <span class="n">R_a</span><span class="p">[:</span><span class="n">pos_holder</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">pos_holder</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>

            <span class="n">row_vector_dependent</span> <span class="o">=</span> <span class="n">column_vector</span><span class="p">[:</span><span class="n">pos_holder</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">row_vector_independent</span> <span class="o">=</span> <span class="n">column_vector</span><span class="p">[</span><span class="n">pos_holder</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>

            <span class="c1">#row_vector = scipy.concatenate((row_vector_independent,row_vector_dependent),1)</span>
            <span class="n">row_vector</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">row_vector_independent</span><span class="p">,</span><span class="n">row_vector_dependent</span><span class="p">))</span>

            <span class="n">column_vector</span> <span class="o">=</span> <span class="n">column_vector</span><span class="p">[</span><span class="n">pos_holder</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
            <span class="n">K_switch</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;no flux conservation&#39;</span><span class="p">)</span>
            <span class="n">r_fpart</span> <span class="o">=</span> <span class="s1">&#39;no flux conservation&#39;</span>
            <span class="n">empty_rf</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">K_switch</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1">#    if r_fpart == &#39;F is empty, R = I&#39;: # 2001/04/26 changed for Python21 compatibility</span>
        <span class="k">if</span> <span class="n">empty_rf</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span><span class="n">r_ipart</span><span class="p">,</span><span class="n">r_ipart</span><span class="p">,</span><span class="n">column_vector</span><span class="p">,</span><span class="n">column_vector</span><span class="p">,</span><span class="n">r_ipart</span><span class="p">,</span><span class="n">column_vector</span><span class="p">,</span><span class="n">K_switch</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">row</span><span class="p">,</span><span class="n">col</span> <span class="o">=</span> <span class="n">r_fpart</span><span class="o">.</span><span class="n">shape</span>
            <span class="nb">id</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">col</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="n">nullspace</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="nb">id</span><span class="p">,</span><span class="o">-</span><span class="n">r_fpart</span><span class="p">),</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

        <span class="c1">#brett 05/11/2002 changed r_fpart to -r_fpart</span>
        <span class="k">return</span><span class="p">(</span><span class="n">r_ipart</span><span class="p">,</span><span class="o">-</span><span class="n">r_fpart</span><span class="p">,</span><span class="n">row_vector</span><span class="p">,</span><span class="n">column_vector</span><span class="p">,</span><span class="n">nullspace</span><span class="p">,</span><span class="n">row_vector_dependent</span><span class="p">,</span><span class="n">K_switch</span><span class="p">)</span></div>


<div class="viewcode-block" id="Stoich.L_split_R"><a class="viewcode-back" href="../../modules_doc.html#cbmpy.PyscesStoich.Stoich.L_split_R">[docs]</a>    <span class="k">def</span> <span class="nf">L_split_R</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">Nfull</span><span class="p">,</span><span class="n">R_a</span><span class="p">,</span><span class="n">row_vector</span><span class="p">,</span><span class="n">column_vector</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        L_split_R(Nfull,R_a,row_vector,column_vector)</span>

<span class="sd">        Takes the Gauss-Jordan factorized N^T and extract the L, Lo, conservation (I -Lo) and reduced stoichiometric matrices. Returns: lmatrix_col_vector, lomatrix, lomatrix_row, lomatrix_co, nrmatrix, Nred_vector_row, Nred_vector_col, info</span>

<span class="sd">        Arguments:</span>

<span class="sd">        Nfull: the original stoichiometric matrix N</span>
<span class="sd">        R_a: gauss-jordan factorized form of N^T</span>
<span class="sd">        row_vector: row tracking vector</span>
<span class="sd">        column_vector: column tracking vector</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,)</span>

        <span class="c1">#print &#39;\nR_a&#39;</span>
        <span class="c1">#print str(R_a)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">commonType</span><span class="p">(</span><span class="n">R_a</span><span class="p">)</span>
        <span class="n">row</span><span class="p">,</span><span class="n">col</span> <span class="o">=</span> <span class="n">R_a</span><span class="o">.</span><span class="n">shape</span>

        <span class="sd">&#39;&#39;&#39;14/09/2000 Seeing as we now should have a perfect staircase in a reduced matrix we do</span>
<span class="sd">        not have to search for the last pivot it will exist at min(row,col)-1 so the pos_holder</span>
<span class="sd">        finding code has been removed (actually moved into self.GetUpperMatrix)&#39;&#39;&#39;</span>

        <span class="n">pos_holder</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="sd">&#39;&#39;&#39;Here we extract the identity matrix from R (future note this could be replaced by an I matrix formed by min(row,col))&#39;&#39;&#39;</span>

        <span class="n">r_ipart</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">pos_holder</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span><span class="n">pos_holder</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="n">r_ipart</span> <span class="o">=</span> <span class="n">R_a</span><span class="p">[:</span><span class="n">pos_holder</span><span class="o">+</span><span class="mi">1</span><span class="p">,:</span><span class="n">pos_holder</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">row_i</span><span class="p">,</span><span class="n">col_i</span> <span class="o">=</span> <span class="n">r_ipart</span><span class="o">.</span><span class="n">shape</span>

    <span class="c1">#    exit1 = &#39;no&#39; # 2001/04/26 changed for Python21 and future compatibility</span>
        <span class="n">exit1</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">L_switch</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1">#added 20020416 class attribute for conservation detection 0 = none, 1 = exists</span>

        <span class="sd">&#39;&#39;&#39;If there are free variable then they are extracted and packaged, row/col vectors are formed&#39;&#39;&#39;</span>

        <span class="k">if</span> <span class="n">col</span> <span class="o">-</span> <span class="n">col_i</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">stoichiometric_analysis_fp_zero</span><span class="p">:</span>
            <span class="n">r_fpart</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">pos_holder</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span><span class="n">col</span> <span class="o">-</span> <span class="p">(</span><span class="n">pos_holder</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="n">r_fpart</span> <span class="o">=</span> <span class="n">R_a</span><span class="p">[:</span><span class="n">pos_holder</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">pos_holder</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>

            <span class="n">col_vector_dependent</span> <span class="o">=</span> <span class="n">column_vector</span><span class="p">[</span><span class="n">pos_holder</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
            <span class="n">col_vector_independent</span> <span class="o">=</span> <span class="n">column_vector</span><span class="p">[:</span><span class="n">pos_holder</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="c1">#cons_col_vector = scipy.concatenate((col_vector_independent,col_vector_dependent),1)</span>
            <span class="n">cons_col_vector</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">col_vector_independent</span><span class="p">,</span><span class="n">col_vector_dependent</span><span class="p">))</span>
            <span class="n">cons_row_vector</span> <span class="o">=</span> <span class="n">col_vector_dependent</span>
            <span class="c1">#lmatrix_row_vector = scipy.concatenate((col_vector_independent,col_vector_dependent),1)</span>
            <span class="n">lmatrix_row_vector</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">col_vector_independent</span><span class="p">,</span><span class="n">col_vector_dependent</span><span class="p">))</span>
            <span class="n">lmatrix_col_vector</span> <span class="o">=</span> <span class="n">col_vector_independent</span>
            <span class="n">lomatrix_row_vector</span> <span class="o">=</span> <span class="n">col_vector_dependent</span>
            <span class="n">lomatrix_col_vector</span> <span class="o">=</span> <span class="n">col_vector_independent</span>
            <span class="n">Nred_vector</span> <span class="o">=</span> <span class="n">col_vector_independent</span>
            <span class="n">L_switch</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lomatrix_row_vector</span> <span class="o">=</span> <span class="n">column_vector</span><span class="p">[:</span><span class="n">pos_holder</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">lomatrix_col_vector</span> <span class="o">=</span> <span class="n">column_vector</span><span class="p">[:</span><span class="n">pos_holder</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">Nred_vector</span> <span class="o">=</span> <span class="n">column_vector</span><span class="p">[:</span><span class="n">pos_holder</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="c1">#print(&#39;F is empty, R = I, no conservation matrix, L is Lo&#39;)</span>
            <span class="n">r_fpart</span> <span class="o">=</span> <span class="n">r_ipart</span>
    <span class="c1">#        exit1 = &#39;yes&#39; # 2001/04/26 changed for Python21 and future compatibility</span>
            <span class="n">exit1</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">L_switch</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1">#    if exit1 == &#39;yes&#39;: # 2001/04/26 changed for Python21 and future compatibility</span>
        <span class="k">if</span> <span class="n">exit1</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">r_fpart</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">r_fpart</span><span class="p">)</span>
            <span class="n">lmatrix</span> <span class="o">=</span> <span class="n">r_fpart</span>
            <span class="c1">#02/10/2000 removed so that the thing returns the Lo matrix as L</span>
            <span class="c1">#r_fpart = &#39;no conservation Lo = L = I&#39;</span>
            <span class="c1"># my factorization routines now swap things around for numeric stability, so that Nr might be a row/column swapped</span>
            <span class="c1"># this simply synchronizes Nr with its labels - brett 20050805</span>
            <span class="n">Nfull</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">Nfull</span><span class="p">)</span>
            <span class="n">row</span><span class="p">,</span><span class="n">col</span> <span class="o">=</span> <span class="n">Nfull</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">Nred</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">row_i</span><span class="p">,</span><span class="n">col</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">row_i</span><span class="p">):</span>
                <span class="n">Nred</span><span class="p">[</span><span class="n">x</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">Nfull</span><span class="p">[</span><span class="n">Nred_vector</span><span class="p">[</span><span class="n">x</span><span class="p">],:]</span>
            <span class="c1"># return the right stuff - brett 20050805</span>
            <span class="k">return</span><span class="p">(</span><span class="n">r_ipart</span><span class="p">,</span><span class="s1">&#39;no conservation&#39;</span><span class="p">,</span><span class="s1">&#39;no conservation&#39;</span><span class="p">,</span><span class="s1">&#39;no conservation&#39;</span><span class="p">,</span><span class="n">lmatrix</span><span class="p">,</span><span class="n">lomatrix_row_vector</span><span class="p">,</span><span class="n">lomatrix_col_vector</span><span class="p">,</span><span class="n">lmatrix</span><span class="p">,</span><span class="n">lomatrix_row_vector</span><span class="p">,</span><span class="n">lomatrix_col_vector</span><span class="p">,</span><span class="n">Nred</span><span class="p">,</span><span class="n">Nred_vector</span><span class="p">,</span><span class="n">row_vector</span><span class="p">,</span><span class="n">L_switch</span><span class="p">)</span>
            <span class="c1">#return(r_ipart,&#39;no conservation&#39;,&#39;no conservation&#39;,&#39;no conservation&#39;,lmatrix,lomatrix_row_vector,lomatrix_col_vector,lmatrix,lomatrix_row_vector,lomatrix_col_vector,scipy.transpose(Nfull),Nred_vector,row_vector,L_switch)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">r_fpart</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">r_fpart</span><span class="p">)</span>
            <span class="n">row</span><span class="p">,</span><span class="n">col</span> <span class="o">=</span> <span class="n">r_fpart</span><span class="o">.</span><span class="n">shape</span>

            <span class="nb">id</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">row</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="c1">#consmatrix = scipy.concatenate((-r_fpart,id),1).astype(t)</span>
            <span class="n">consmatrix</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="o">-</span><span class="n">r_fpart</span><span class="p">,</span><span class="nb">id</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

            <span class="nb">id</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">col</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="n">lmatrix</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="nb">id</span><span class="p">,</span><span class="n">r_fpart</span><span class="p">),</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

            <span class="sd">&#39;&#39;&#39;This bit creates Nr. The transpose is only necessary if Nfull is already transposed in the input function&#39;&#39;&#39;</span>

            <span class="n">Nfull</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">Nfull</span><span class="p">)</span>
            <span class="n">row</span><span class="p">,</span><span class="n">col</span> <span class="o">=</span> <span class="n">Nfull</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">Nred</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">row_i</span><span class="p">,</span><span class="n">col</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">row_i</span><span class="p">):</span>
                <span class="n">Nred</span><span class="p">[</span><span class="n">x</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">Nfull</span><span class="p">[</span><span class="n">Nred_vector</span><span class="p">[</span><span class="n">x</span><span class="p">],:]</span>

            <span class="k">return</span><span class="p">(</span><span class="n">r_ipart</span><span class="p">,</span><span class="n">consmatrix</span><span class="p">,</span><span class="n">cons_row_vector</span><span class="p">,</span><span class="n">cons_col_vector</span><span class="p">,</span><span class="n">lmatrix</span><span class="p">,</span><span class="n">lmatrix_row_vector</span><span class="p">,</span><span class="n">lmatrix_col_vector</span><span class="p">,</span><span class="n">r_fpart</span><span class="p">,</span><span class="n">lomatrix_row_vector</span><span class="p">,</span><span class="n">lomatrix_col_vector</span><span class="p">,</span><span class="n">Nred</span><span class="p">,</span><span class="n">Nred_vector</span><span class="p">,</span><span class="n">row_vector</span><span class="p">,</span><span class="n">L_switch</span><span class="p">)</span></div>


<div class="viewcode-block" id="Stoich.SVD_Rank_Check"><a class="viewcode-back" href="../../modules_doc.html#cbmpy.PyscesStoich.Stoich.SVD_Rank_Check">[docs]</a>    <span class="k">def</span> <span class="nf">SVD_Rank_Check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">matrix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">factor</span><span class="o">=</span><span class="mf">1.0e4</span><span class="p">,</span><span class="n">resultback</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        SVD_Rank_Check(matrix=None,factor=1.0e4,resultback=0)</span>

<span class="sd">        Calculates the dimensions of L/L0/K/K) by way of SVD and compares them to the Guass-Jordan results. Please note that for LARGE ill conditioned matrices the SVD can become numerically unstable when used for nullspace determinations</span>

<span class="sd">        Arguments:</span>

<span class="sd">        matrix [default=None]: the stoichiometric matrix default is self.Nmatrix</span>
<span class="sd">        factor [default=1.0e4]: factor used to calculate the &#39;zero pivot&#39; mask = mach_eps*factor</span>
<span class="sd">        resultback [default=0]: return the SVD results, U, S, vh</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">matrix</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmatrix</span>

        <span class="n">nrow</span><span class="p">,</span><span class="n">ncol</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">TrMat</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">ncol</span> <span class="o">&gt;</span> <span class="n">nrow</span><span class="p">:</span>
            <span class="c1"># &#39;INFO: SVD is more accurate for tall matrices using (N)T\n&#39;</span>
            <span class="n">matrix</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
            <span class="n">TrMat</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="n">u</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">vh</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
        <span class="n">maskF</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">machar</span><span class="o">.</span><span class="n">machar_double</span><span class="o">.</span><span class="n">eps</span><span class="o">*</span><span class="n">factor</span>

        <span class="k">if</span> <span class="n">TrMat</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;SVD zero mask:&#39;</span><span class="p">,</span> <span class="n">maskF</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;LU factorization effective zero:&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stoichiometric_analysis_lu_precision</span><span class="p">)</span>

            <span class="n">rank</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">el</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">maskF</span><span class="p">)</span> <span class="k">if</span> <span class="n">el</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">])</span>
<span class="c1">##            null_mask = (abs(s) &gt; maskF)</span>
<span class="c1">##            vhnull = scipy.compress(null_mask,vh,axis=0)</span>
<span class="c1">##            unull = scipy.compress(null_mask,u,axis=0)</span>
<span class="c1">##            assert vhnull.shape[0] == unull.shape[0], &#39;This should be true or I\&#39;m very confused&#39;</span>
<span class="c1">##            rank = vhnull.shape[0]</span>


            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Nmatrix has &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">nrow</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; rows and &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ncol</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; columns&#39;</span><span class="p">)</span>

            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">SVD </span><span class="se">\&quot;</span><span class="s1">considers</span><span class="se">\&quot;</span><span class="s1"> the rank to be:        &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">rank</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;LU (Kmatrix) considers the rank to be: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kzeromatrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;LU (Lmatrix) considers the rank to be: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lzeromatrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Comparing lzeromatrix dimensions&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;SVD lzeromatrix.shape =&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">rank</span><span class="p">,</span><span class="n">rank</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;LU  lzeromatrix.shape =&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lzeromatrix</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Comparing lmatrix dimensions&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;SVD lmatrix.shape =&#39;</span><span class="p">,</span>     <span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">rank</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;LU  lmatrix.shape =&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmatrix</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Comparing kzeromatrix dimensions&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;SVD kzeromatrix.shape =&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">rank</span><span class="p">,</span><span class="n">vh</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">rank</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;LU  kzeromatrix.shape =&#39;</span><span class="p">,</span>    <span class="bp">self</span><span class="o">.</span><span class="n">kzeromatrix</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Comparing kmatrix dimensions&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;SVD kmatrix.shape =&#39;</span><span class="p">,</span>     <span class="p">(</span><span class="n">vh</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">vh</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">rank</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;LU  kmatrix.shape =&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kmatrix</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;SVD zero mask:&#39;</span><span class="p">,</span> <span class="n">maskF</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;LU factorization effective zero:&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stoichiometric_analysis_lu_precision</span><span class="p">)</span>

            <span class="n">rank</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">el</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">maskF</span><span class="p">)</span> <span class="k">if</span> <span class="n">el</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">])</span>
<span class="c1">##            null_mask = (abs(s) &gt; maskF)</span>
<span class="c1">##            vhnull = scipy.compress(null_mask,vh,axis=0)</span>
<span class="c1">##            unull = scipy.compress(null_mask,u,axis=0)</span>
<span class="c1">##            assert vhnull.shape[0] == unull.shape[0], &#39;This should be true or I\&#39;m very confused&#39;</span>
<span class="c1">##            rank = vhnull.shape[0]</span>


            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Nmatrix has &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">nrow</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; rows and &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ncol</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; columns&#39;</span><span class="p">)</span>

            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">SVD considers the rank to be:          &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">rank</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;LU (Kmatrix) considers the rank to be: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kzeromatrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;LU (Lmatrix) considers the rank to be: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lzeromatrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Comparing lzeromatrix dimensions&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;SVD lzeromatrix.shape =&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">vh</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">rank</span><span class="p">,</span><span class="n">rank</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;LU  lzeromatrix.shape =&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lzeromatrix</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Comparing lmatrix dimensions&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;SVD lmatrix.shape =&#39;</span><span class="p">,</span>     <span class="p">(</span><span class="n">vh</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">rank</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;LU  lmatrix.shape =&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmatrix</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Comparing kzeromatrix dimensions&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;SVD kzeromatrix.shape =&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">rank</span><span class="p">,</span><span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">rank</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;LU  kzeromatrix.shape =&#39;</span><span class="p">,</span>    <span class="bp">self</span><span class="o">.</span><span class="n">kzeromatrix</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Comparing kmatrix dimensions&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;SVD kmatrix.shape =&#39;</span><span class="p">,</span>     <span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">rank</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;LU  kmatrix.shape =&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kmatrix</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Matrix value check</span><span class="se">\n</span><span class="s1">******************&#39;</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Kzeromatrix:&#39;</span><span class="p">)</span>
        <span class="n">sm</span><span class="p">,</span><span class="n">bg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MatrixValueCompare</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kzeromatrix</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Smallest value:  &#39;</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">sm</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Largest value:   &#39;</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">bg</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Ratio abs(bg/sm):&#39;</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">bg</span><span class="o">/</span><span class="n">sm</span><span class="p">))</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Lzeromatrix:&#39;</span><span class="p">)</span>
        <span class="n">sm</span><span class="p">,</span><span class="n">bg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MatrixValueCompare</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lzeromatrix</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Smallest value:  &#39;</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">sm</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Largest value:   &#39;</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">bg</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Ratio abs(bg/sm):&#39;</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">bg</span><span class="o">/</span><span class="n">sm</span><span class="p">))</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Please note: I</span><span class="se">\&#39;</span><span class="s1">ve found that for larger models the rank calculated by SVD in this test can become unstable and give incorrect results.&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">resultback</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">u</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">vh</span></div></div>


<span class="k">if</span> <span class="n">__psyco_active__</span><span class="p">:</span>
    <span class="n">psyco</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">MathArrayFunc</span><span class="p">)</span>
    <span class="n">psyco</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">Stoich</span><span class="p">)</span>

</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../cbmpy.html">
              <img class="logo" src="../../_static/pysces_cbm1_head.jpg" alt="Logo"/>
            </a></p><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../cbmpy.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2010-2017, Brett G. Olivier.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.4.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.9</a>
      
    </div>

    

    
  </body>
</html>